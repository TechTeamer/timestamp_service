{"version":3,"file":"timestamp_config.cjs","sources":["../../src/util/regexParser.ts","../../src/trustedTimestamp/TrustedTimestampInfo.ts","../../src/patch/node-fetch.ts","../../src/trustedTimestamp/TimestampRequest.ts","../../src/trustedTimestamp/TrustedTimestampRequest.ts","../../src/util/child_process_promise.ts","../../src/trustedTimestamp/TrustedTimestampCommand.ts","../../src/trustedTimestamp/TrustedTimestampCheck.ts","../../src/util/TempFileService.ts","../../src/trustedTimestamp/error/create-timestamp-token.error.ts","../../src/trustedTimestamp/TrustedTimestampService.ts"],"sourcesContent":["function parseRegex<Groups extends number | (string | number)[] | undefined, ReviveResult>(\n  text: string,\n  regex: RegExp,\n  groups: Groups,\n  revive: (\n    parameter: Groups extends number\n      ? string\n      : Groups extends (string | number)[]\n        ? Record<string | number, string>\n        : RegExpMatchArray\n  ) => ReviveResult = value => value as unknown as ReviveResult\n): ReviveResult | null | undefined {\n  const result = text.match(regex)\n  if (!result) {\n    return null\n  }\n\n  if (!groups) {\n    return (revive as (parameter: RegExpMatchArray) => ReviveResult)(result)\n  }\n\n  if (typeof groups === 'number') {\n    return (revive as (parameter: string) => ReviveResult)(result[groups])\n  }\n\n  if (Array.isArray(groups)) {\n    const ret: Record<string | number, string> = {}\n    groups.forEach((name, i) => {\n      ret[name] = result[i + 1]\n    })\n    return (revive as (parameter: Record<string | number, string>) => ReviveResult)(ret)\n  }\n}\n\nfunction createParser<ReviveResult = unknown>(\n  regex: RegExp,\n  groups: number | number[],\n  revive: (value: unknown) => ReviveResult\n): (text: string) => ReviveResult | null | undefined {\n  return (text: string) => {\n    return parseRegex(text, regex, groups, revive)\n  }\n}\n\nexport { createParser as create }\nexport { parseRegex }\n","import { CertService } from '@techteamer/cert-utils'\nimport { parseRegex } from '../util/regexParser'\n\ninterface TSA {\n  C: string | null\n  L: string | null\n  O: string | null\n  OU: string | null\n  CN: string | null\n}\n\n/**\n *\n * Status info:\n * Status: Granted.\n * Status description: unspecified\n * Failure info: unspecified\n *\n * TST info:\n * Version: 1\n * Policy OID: 1.3.6.1.4.1.21528.2.2.99\n * Hash Algorithm: sha256\n * Message data:\n * 0000 - c5 3e 94 56 aa 61 ed 56-49 69 74 29 1e 01 d7 2a   .>.V.a.VIit)...*\n * 0010 - 64 cc 24 84 d2 a2 31 4d-33 b6 ca c8 98 23 03 b9   d.$...1M3....#..\n * Serial number: 0x0308441E\n * Time stamp: Jan 30 13:45:20 2018 GMT\n * Accuracy: 0x01 seconds, unspecified millis, unspecified micros\n * Ordering: no\n * Nonce: unspecified\n * TSA: DirName:/C=HU/L=Budapest/O=Microsec Ltd./OU=e-Szigno CA/CN=e-Szigno Test TSA2\n * Extensions:\n * */\nexport class TimestampInfo {\n  error: string | null = null\n  version: number | null = null\n  policyOID: string | null = null\n  hashAlgorithm: string | null = null\n  hash: string | null = null\n  serialNumber: string | null = null\n  timeStamp: Date | null = null\n  timeStampDate: Date | null = null\n  accuracy: number | null = null\n  ordering: boolean | null = null\n  nonce: string | null = null\n  issuer: string | null = null\n  tsa: TSA | null = null\n  certInfo: CertService['CertInfo'] | null = null\n\n  constructor(timestampInfoType: 'normal' | 'short' = 'normal', tsText: string, error: string | null = null) {\n    this.error = null\n    this.version = null\n    this.policyOID = null\n    this.hashAlgorithm = null\n    this.serialNumber = null\n    this.timeStamp = null\n    this.accuracy = null\n    this.ordering = null\n    this.nonce = null\n    this.tsa = null\n\n    if (error) {\n      this.error = error\n    } else {\n      if (timestampInfoType === 'short') {\n        this.parseOpensslOutputShort(tsText)\n      } else {\n        this.hash = null\n        this.timeStampDate = null\n        this.issuer = null\n        this.certInfo = null\n        this.parseOpensslOutput(tsText)\n      }\n    }\n  }\n\n  setCertInfo(certInfo: CertService['CertInfo'] | null): void {\n    this.certInfo = certInfo\n  }\n\n  parseOpensslOutput(tsText: string): void {\n    this.version = parseRegex(tsText, /Version:\\s*([^\\n\\r]+)/, 1, parseInt)!\n    this.policyOID = parseRegex(tsText, /Policy OID:\\s*([^\\n\\r]+)/, 1)!\n    this.hashAlgorithm = parseRegex(tsText, /Hash Algorithm:\\s*([^\\n\\r]+)/, 1)!\n    this.hash = tsText\n      .match(/\\d{4} - .*?\\s{2}/g)!\n      .map(line => {\n        return line.replace(/\\d{4} - /g, '').replace(/[\\s*-]/g, '')\n      })\n      .join('')\n    this.serialNumber = parseRegex(tsText, /Serial number:\\s*([^\\n\\r]+)/, 1)!\n    this.timeStamp = parseRegex(tsText, /Time stamp:\\s*([^\\n\\r]+)/, 1)!\n    this.timeStampDate = new Date(this.timeStamp)\n    this.accuracy = parseRegex(\n      tsText,\n      /Accuracy:\\s*(.+) seconds, (.+) millis, (.+) micros/,\n      ['s', 'm', 'u'],\n      ({ s, m, u }) => {\n        const _s = Number(s === 'unspecified' ? 0 : s)\n        const _m = Number(m === 'unspecified' ? 0 : m)\n        const _u = Number(u === 'unspecified' ? 0 : u)\n        return _s * 1000 + _m + _u / 1000\n      }\n    )!\n    this.ordering = parseRegex(tsText, /Ordering:\\s*([^\\n\\r]+)/, 1, ordering => ordering !== 'no')!\n    this.nonce = parseRegex(tsText, /Nonce:\\s*([^\\n\\r]+)/, 1, nonce => (nonce === 'unspecified' ? null : nonce))!\n    this.issuer = parseRegex(tsText, /TSA:\\s*DirName:\\s*([^\\n\\r]+)/, 1)!\n    this.tsa = parseRegex(tsText, /TSA:\\s*DirName:\\s*([^\\n\\r]+)/, 1, (result): TSA => {\n      const m = result.match(/\\/\\w{1,2}=[^/]+/g) || []\n\n      return m.reduce(\n        (obj, part) => {\n          const [, label, value] = part.match(/\\/(\\w{1,2})=([^/]+)/) || []\n          if (!label || !value) {\n            return obj\n          }\n          obj[label as keyof TSA] = value\n          return obj\n        },\n        { C: null, L: null, O: null, OU: null, CN: null } as TSA\n      )\n    })!\n  }\n\n  parseOpensslOutputShort(tsText: string): void {\n    this.version = parseRegex(tsText, /Version:\\s*([^\\n\\r]+)/, 1, parseInt)!\n    this.policyOID = parseRegex(tsText, /Policy OID:\\s*([^\\n\\r]+)/, 1)!\n    this.hashAlgorithm = parseRegex(tsText, /Hash Algorithm:\\s*([^\\n\\r]+)/, 1)!\n    this.serialNumber = parseRegex(tsText, /Serial number:\\s*([^\\n\\r]+)/, 1)!\n    this.timeStamp = parseRegex(tsText, /Time stamp:\\s*([^\\n\\r]+)/, 1, dateString => new Date(dateString))!\n    this.accuracy = parseRegex(\n      tsText,\n      /Accuracy:\\s*(.+) seconds, (.+) millis, (.+) micros/,\n      ['s', 'm', 'u'],\n      ({ s, m, u }) => {\n        const _s = Number(s === 'unspecified' ? 0 : s)\n        const _m = Number(m === 'unspecified' ? 0 : m)\n        const _u = Number(u === 'unspecified' ? 0 : u)\n        return _s * 1000 + _m + _u / 1000\n      }\n    )!\n    this.ordering = parseRegex(tsText, /Ordering:\\s*([^\\n\\r]+)/, 1, ordering => ordering !== 'no')!\n    this.nonce = parseRegex(tsText, /Nonce:\\s*([^\\n\\r]+)/, 1, nonce => (nonce === 'unspecified' ? null : nonce))!\n    this.tsa = parseRegex(tsText, /TSA:\\s*([^\\n\\r]+)/, 1, v => {\n      const m = v.match(/\\/\\w{1,2}=[^/]+/g) || []\n\n      return m.reduce(\n        (obj, part) => {\n          const [, label, value] = part.match(/\\/(\\w{1,2})=([^/]+)/) || []\n          if (!label || !value) {\n            return obj\n          }\n          obj[label as keyof TSA] = value\n          return obj\n        },\n        { C: null, L: null, O: null, OU: null, CN: null } as TSA\n      )\n    })!\n  }\n}\n","import type { RequestInfo, RequestInit, Response } from 'node-fetch'\n\nexport const fetch = async (url: URL | RequestInfo, init?: RequestInit): Promise<Response> => {\n  const { default: fetch } = await import('node-fetch')\n  return fetch(url, init)\n}\n","import type { BodyInit } from 'node-fetch'\nimport { fetch } from '../patch/node-fetch'\nimport fs from 'node:fs'\nimport { ProxyAgent } from 'proxy-agent'\nimport type { FileOptions } from 'tmp'\n\nimport type {\n  TimestampRequestAuthResult,\n  TimestampRequestAuthTypes,\n  TimestampRequestError,\n  TimestampRequestOptions\n} from './types/timestamp-request.type'\nimport type {\n  TimestampProviderAuth,\n  TimestampProviderBody,\n  TimestampProviderOAuthUrl,\n  TimestampProviderProxyConfig,\n  TimestampProviderUrl\n} from './types/timestamp-provider.type'\nimport type { TempFileService } from '../util/TempFileService'\n\n/**\n * TimestampRequest class implements timestamp request\n * */\nexport class TimestampRequest {\n  private tsRequest: TimestampRequestOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/timestamp-query'\n    }\n  }\n\n  constructor(\n    private readonly tempFileService: TempFileService,\n    private readonly tmpOptions: FileOptions,\n    private readonly cleanupTempFns: ((...args: unknown[]) => unknown)[]\n  ) {}\n\n  /**\n   * set request header\n   * */\n  setHeader(headers: Record<string, string>): void {\n    this.tsRequest = {\n      ...this.tsRequest,\n      headers\n    }\n  }\n\n  /**\n   * set request body\n   * */\n  setBody(body: BodyInit): void {\n    this.tsRequest.body = body\n  }\n\n  /**\n   * set request proxy\n   * */\n  setProxy(proxy: TimestampProviderProxyConfig): void {\n    this.tsRequest.agent = new ProxyAgent({\n      getProxyForUrl: (): string => proxy.url,\n      rejectUnauthorized: !(proxy.allowUnauthorized ?? false)\n    })\n  }\n\n  /**\n   * set request encoding\n   * */\n  setEncoding(encoding: string | null): void {\n    this.tsRequest.encoding = encoding\n  }\n\n  /**\n   * set request encoding\n   * */\n  setResolveWithFullResponse(resolveWithFullResponse: boolean): void {\n    this.tsRequest.resolveWithFullResponse = resolveWithFullResponse\n  }\n\n  /**\n   * return tsRequest\n   * */\n  get(): TimestampRequestOptions {\n    return this.tsRequest\n  }\n\n  /**\n   * authStrategy method that set no auth request\n   * */\n  async authStrategy(\n    requestType: TimestampRequestAuthTypes | undefined,\n    url: TimestampProviderUrl,\n    auth: TimestampProviderAuth | undefined,\n    body: TimestampProviderBody | undefined,\n    proxy: TimestampProviderProxyConfig | undefined,\n    tsQuery: string\n  ): Promise<TimestampRequestAuthResult> {\n    switch (requestType) {\n      case 'basic':\n        return this._getTimestampRequestBasic(url as string, auth!, tsQuery)\n      case 'oauth':\n        return await this._getTimestampRequestOauth(url as TimestampProviderOAuthUrl, auth!, body, proxy, tsQuery)\n      case 'noAuth':\n        return this._getTimestampRequestNoAuth(url as string, tsQuery)\n      default:\n        return this._getTimestampRequestNoAuth(url as string, tsQuery)\n    }\n  }\n\n  /**\n   * _getTimestampRequestBasic method that set basic auth request\n   * */\n  private _getTimestampRequestBasic(\n    url: string,\n    auth: TimestampProviderAuth,\n    tsQuery: string\n  ): TimestampRequestAuthResult {\n    this.setHeader({\n      ...this.tsRequest.headers,\n      Authorization: `Basic ${Buffer.from(auth.user + ':' + auth.pass).toString('base64')}`\n    })\n\n    this.setEncoding(null) // we expect binary data in a buffer: ensure that the response is not decoded unnecessarily\n    this.setResolveWithFullResponse(true)\n    this.setBody(tsQuery)\n\n    return { requestUrl: url, tsRequest: this.get() }\n  }\n\n  /**\n   * _getTimestampRequestOauth method that set oauth request\n   * */\n  private async _getTimestampRequestOauth(\n    url: TimestampProviderOAuthUrl,\n    auth: TimestampProviderAuth,\n    body: TimestampProviderBody | undefined,\n    proxy: TimestampProviderProxyConfig | undefined,\n    tsQuery: string\n  ): Promise<TimestampRequestAuthResult> {\n    const oauthResult = await this._getOauth<{\n      access_token?: string\n      error?: TimestampRequestError\n    }>(url.getTokenUrl, auth, body, proxy)\n    if (!oauthResult?.access_token) {\n      return { requestUrl: null, tsRequest: null, error: null }\n    }\n\n    if (oauthResult?.error) {\n      return { requestUrl: null, tsRequest: null, error: oauthResult?.error }\n    }\n\n    const accessToken = oauthResult?.access_token\n\n    if (accessToken) {\n      this.setHeader({\n        ...this.tsRequest.headers,\n        Authorization: `Bearer ${accessToken}`\n      })\n\n      const { tempPath, cleanupCallback } = await this.tempFileService.createTempFile(\n        this.tmpOptions,\n        Buffer.from(tsQuery)\n      )\n      this.cleanupTempFns.push(cleanupCallback)\n\n      const stats = fs.statSync(tempPath)\n      const fileSizeInBytes = stats.size\n      this.setBody(fs.createReadStream(tempPath))\n      this.setHeader({\n        ...this.tsRequest.headers,\n        'Content-length': fileSizeInBytes.toString()\n      })\n    }\n\n    return { requestUrl: url?.getTimestampUrl, tsRequest: this.get(), error: null }\n  }\n\n  /**\n   * _getTimestampRequestNoAuth method that set no auth request\n   * */\n  private _getTimestampRequestNoAuth(url: string, tsQuery: string): TimestampRequestAuthResult {\n    this.setEncoding(null) // we expect binary data in a buffer: ensure that the response is not decoded unnecessarily\n    this.setResolveWithFullResponse(true)\n    this.setBody(tsQuery)\n\n    return { requestUrl: url, tsRequest: this.get() }\n  }\n\n  /**\n   * _getOauth method that get oauth access_token\n   **/\n  private async _getOauth<ResponseType extends { error?: TimestampRequestError }>(\n    url: string,\n    auth: TimestampProviderAuth,\n    body: TimestampProviderBody | undefined,\n    proxy: TimestampProviderProxyConfig | undefined\n  ): Promise<ResponseType> {\n    const tsRequest = await this._getOauthRequestSettings(auth, body, proxy)\n    try {\n      const response = await fetch(url, tsRequest)\n      return (await response.json()) as ResponseType\n    } catch (error) {\n      return {\n        error: {\n          message: (error as Error).message,\n          trace: error as Error\n        }\n      } as ResponseType\n    }\n  }\n\n  /**\n   * _getOauthRequestSettings method that set the request oath settings\n   **/\n  private async _getOauthRequestSettings(\n    auth: TimestampProviderAuth,\n    body: TimestampProviderBody | undefined,\n    proxy: TimestampProviderProxyConfig | undefined\n  ): Promise<TimestampRequestOptions<ProxyAgent>> {\n    const tsRequest: TimestampRequestOptions<ProxyAgent> = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${Buffer.from(auth.user + ':' + auth.pass).toString('base64')}`\n      },\n      body: new URLSearchParams(body)\n    }\n\n    if (proxy?.url) {\n      tsRequest.agent = new ProxyAgent({\n        getProxyForUrl: (): string => proxy.url,\n        rejectUnauthorized: !(proxy.allowUnauthorized ?? false)\n      })\n    }\n\n    return tsRequest\n  }\n}\n","import { FileOptions as TempFileOptions } from 'tmp'\nimport { fetch } from '../patch/node-fetch'\n\nimport { TimestampRequest } from './TimestampRequest'\nimport { TempFileService } from '../util/TempFileService'\nimport type { TimestampRequestAuthResult, TimestampRequestAuthTypes } from './types/timestamp-request.type'\nimport type {\n  TimestampProvider,\n  TimestampProviderAuth,\n  TimestampProviderBody,\n  TimestampProviderOAuthUrl,\n  TimestampProviderProxyConfig,\n  TimestampProviderUrl\n} from './types/timestamp-provider.type'\nimport type { TimestampLog } from './types/timestamp-log.type'\n\n/**\n * TrustedTimestampRequest service implements timestamp request and sorted providers\n * */\nexport class TrustedTimestampRequest {\n  private readonly cleanupTempFns: (() => unknown)[] = []\n  private readonly providers: TimestampProvider[]\n\n  constructor(\n    providers: TimestampProvider[],\n    private readonly tempFileService: TempFileService,\n    private readonly tmpOptions: TempFileOptions\n  ) {\n    this.providers = this._sortedProviders(providers)\n  }\n\n  /**\n   * getTimestamp method that calls the service providers in sequence, requesting a timestamp\n   **/\n  async getTimestamp(\n    tsQuery: string\n  ): Promise<{ tsr: Buffer | null; providerName: string; logHistory: TimestampLog[] }> {\n    let tsr = null\n    let providerName = ''\n    const logHistory: TimestampLog[] = []\n\n    for (const provider of this.providers) {\n      if (!tsr) {\n        const { name, url, auth, body, proxy } = provider\n\n        if (!name) {\n          throw new Error('Provider name is missing')\n        }\n        if (!url) {\n          throw new Error('Provider url is missing')\n        }\n\n        const { timestampToken, log } = await this._getTimeStampToken(name, url, auth, body, proxy, tsQuery)\n        logHistory.push(log)\n        tsr = timestampToken\n        providerName = name\n      }\n    }\n\n    return { tsr, providerName, logHistory }\n  }\n\n  /**\n   * sortedProviders method that sorting the providers according to priority\n   **/\n  private _sortedProviders(providers: TimestampProvider[]): TimestampProvider[] {\n    const priorityProviders: TimestampProvider[] = []\n    const nonPriorityProviders: TimestampProvider[] = []\n\n    providers.forEach(provider => {\n      if (provider?.priority) {\n        priorityProviders.push(provider)\n      } else {\n        nonPriorityProviders.push(provider)\n      }\n    })\n\n    const sortedProviders = priorityProviders.toSorted((a, b) => a.priority! - b.priority!)\n\n    return sortedProviders.concat(nonPriorityProviders)\n  }\n\n  /**\n   * sendTimestampRequest method that calls the provider\n   **/\n  private async _getTimeStampToken(\n    name: string,\n    url: TimestampProviderUrl,\n    auth: TimestampProviderAuth | undefined,\n    body: TimestampProviderBody | undefined,\n    proxy: TimestampProviderProxyConfig | undefined,\n    tsQuery: string\n  ): Promise<{\n    timestampToken: null | Buffer\n    log: TimestampLog\n  }> {\n    const { requestUrl, tsRequest, error } = await this._getTimestampRequest(url, body, auth, proxy, tsQuery)\n    if (error) {\n      return {\n        timestampToken: null,\n        log: {\n          info: { name, info: null, date: new Date(), url, response: null, error: error?.message },\n          errorTrace: error?.trace\n        }\n      }\n    }\n    try {\n      const response = await fetch(requestUrl!, tsRequest!)\n      if (response.status !== 200) {\n        throw new Error(`TSA response unsatisfactory: ${response.status} ${response.statusText}`)\n      }\n\n      return {\n        timestampToken: Buffer.from((await response.arrayBuffer()) as unknown as string, 'utf8'), // TODO: fix type\n        log: {\n          info: { name, date: new Date(), url, response: `${response.status}, ${response.statusText}`, error: null },\n          errorTrace: null\n        }\n      }\n    } catch (error) {\n      return {\n        timestampToken: null,\n        log: {\n          info: { name, date: new Date(), url, response: null, error: (error as Error).message },\n          errorTrace: error as Error\n        }\n      }\n    } finally {\n      for (const cleanUpFn of this.cleanupTempFns) {\n        if (typeof cleanUpFn === 'function') {\n          cleanUpFn()\n        }\n      }\n    }\n  }\n\n  /**\n   * getTimestampRequestSettings method that set the request settings\n   **/\n  private async _getTimestampRequest(\n    url: TimestampProviderUrl,\n    body: TimestampProviderBody | undefined,\n    auth: TimestampProviderAuth | undefined,\n    proxy: TimestampProviderProxyConfig | undefined,\n    tsQuery: string\n  ): Promise<TimestampRequestAuthResult> {\n    // send the request to the TSA\n    const tsRequest = new TimestampRequest(this.tempFileService, this.tmpOptions, this.cleanupTempFns)\n\n    if (proxy?.url) {\n      tsRequest.setProxy(proxy)\n    }\n\n    let requestType: TimestampRequestAuthTypes | undefined\n    if ((url as TimestampProviderOAuthUrl)?.getTokenUrl && tsQuery) {\n      requestType = 'oauth'\n    }\n    if (!(url as TimestampProviderOAuthUrl)?.getTokenUrl && auth?.user && auth?.pass && tsQuery) {\n      requestType = 'basic'\n    }\n    if (!(url as TimestampProviderOAuthUrl)?.getTokenUrl && !auth?.user) {\n      requestType = 'noAuth'\n    }\n\n    return await tsRequest.authStrategy(requestType, url, auth, body, proxy, tsQuery)\n  }\n}\n","import * as childProcess from 'node:child_process'\nimport type { ExecOptions } from 'node:child_process'\n\ninterface Logger {\n  info: (log: string, ...args: unknown[]) => unknown\n  error: (log: string, ...args: unknown[]) => unknown\n}\n\nexport function exec<ReturnType = string>(\n  command: string,\n  options: {\n    encoding?: 'buffer'\n  } & ExecOptions = {},\n  logger?: Logger\n): Promise<ReturnType> {\n  return new Promise<ReturnType>((resolve, reject) => {\n    const process = childProcess.exec(command, options, (err, stdout, stderr) => {\n      if (err) {\n        return reject(err || new Error(stderr.toString() || `Failed to execute command: ${command}`))\n      }\n\n      return resolve(stdout as ReturnType)\n    })\n\n    if (logger) {\n      process.stdout!.on('data', message => {\n        message = message.trim()\n        if (message) {\n          logger.info(message)\n        }\n      })\n\n      process.stderr!.on('data', message => {\n        message = message.trim()\n        if (message) {\n          logger.error(message)\n        }\n      })\n    }\n  })\n}\n\nexport class ExecFileError extends Error {\n  public stdout?: string\n  public stderr?: string\n}\n\nexport function execFile(command: string, args: string[], options = {}): Promise<{ stdout: string; stderr: string }> {\n  return new Promise((resolve, reject) => {\n    childProcess.execFile(command, args, options, (err, stdout, stderr) => {\n      if (err) {\n        const error = new ExecFileError(err ? err.message : stderr.toString() || `Failed to execute file: ${command}`)\n        error.stdout = stdout\n        error.stderr = stderr\n        return reject(error)\n      }\n\n      resolve({ stdout, stderr })\n    })\n  })\n}\n","import { exec } from '../util/child_process_promise'\n\nexport async function getTsQuery(digest: string, digestFormat: string): Promise<string> {\n  // create a time stamp request based on the hash of a data file\n  const queryCommand = `openssl ts -query -digest ${digest} -no_nonce -${digestFormat} -cert`\n\n  return await exec(queryCommand, { encoding: 'buffer' }).catch(err => {\n    throw new Error(`Failed to execute openssl ts -query command \"${queryCommand}\" ${err.message}`)\n  })\n}\n\nexport function getTsVerify(\n  digest: string,\n  tempPath: string,\n  isToken: boolean,\n  certsLocation: string\n): Promise<string> {\n  // verify the response with openssl\n  const verifyCommand = isToken\n    ? `openssl ts -verify -digest ${digest} -token_in -in ${tempPath} -CApath ${certsLocation}`\n    : `openssl ts -verify -digest ${digest} -in ${tempPath} -CApath ${certsLocation}`\n\n  return exec(verifyCommand).catch(err => {\n    throw new Error(`Failed to verify tsr \"${verifyCommand}\" ${err.message}`)\n  })\n}\n\nexport async function getTsReply(inputTempPath: string, isToken: boolean): Promise<string> {\n  // get token info\n  const replyCommand = isToken\n    ? `openssl ts -reply -token_in -in ${inputTempPath} -text`\n    : `openssl ts -reply -in ${inputTempPath} -text`\n  return await exec(replyCommand).catch(err => {\n    throw new Error(`Error executing openssl ts -reply command \"${replyCommand}\" ${err.message}`)\n  })\n}\n\nexport async function generateTsReply(inputTempPath: string, tempPath: string): Promise<void> {\n  await exec(`openssl ts -reply -in \"${inputTempPath}\" -token_out -out \"${tempPath}\"`).catch(err => {\n    throw new Error(`Error executing openssl ts -reply command \"${inputTempPath}\" ${err.message}`)\n  })\n}\n\nexport async function extractCertFromToken(tstPath: string): Promise<string> {\n  return await exec(`openssl pkcs7 -inform der -in \"${tstPath}\" -print_certs`).catch(err => {\n    throw new Error(`Error executing openssl pkcs7 command ${err.message}`)\n  })\n}\n\nexport async function checkSslPath(): Promise<string> {\n  try {\n    const stdout = await exec('which openssl')\n    if (!stdout.toString()) {\n      throw new Error('openssl is unavailable')\n    }\n    return stdout\n  } catch (error) {\n    throw new Error(`Unable to verify openssl installation ${(error as Error).message}`)\n  }\n}\n","const supportedDigestForamts = [\n  'sha',\n  'sha1',\n  'mdc2',\n  'ripemd160',\n  'sha224',\n  'sha256',\n  'sha384',\n  'sha512',\n  'md2',\n  'md4',\n  'md5',\n  'dss1'\n]\n\nexport function checkDigestFormat(format: string): boolean {\n  return supportedDigestForamts.includes(format)\n}\n\nexport function checkDigest(digest: string): boolean {\n  return /^([0-9A-F])+$/i.test(digest)\n}\n\nexport function normalizeDigestFormat(format: string): string {\n  return format\n    .replace(/^-/, '') // -sha256\n    .replace(/-/g, '') // sha-256\n}\n","import fs from 'node:fs/promises'\nimport util from 'node:util'\nimport tmp from 'tmp'\n\ntmp.setGracefulCleanup()\n\nconst tmpFile = util.promisify(\n  (\n    options: tmp.FileOptions,\n    cb: (error: Error | null, results: [string, number | undefined, () => void]) => unknown\n  ) => {\n    tmp.file(options, (err, ...results) => cb(err, results))\n  }\n)\n\nexport class TempFileService {\n  /**\n   * Utility to create a temp file with content\n   * */\n  async createTempFile(\n    options: tmp.FileOptions,\n    content?: Buffer\n  ): Promise<{ tempPath: string; fd: number | undefined; cleanupCallback: () => void }> {\n    try {\n      const [tempPath, fd, cleanupCallback] = await tmpFile(options)\n      if (content) {\n        await fs.writeFile(tempPath, content as unknown as string)\n      }\n      return { tempPath, fd, cleanupCallback }\n    } catch (err) {\n      throw new Error(`Failed to create temp file ${err}`)\n    }\n  }\n}\n","import { CreatedTimestampToken } from '../types/timestamp-token.type'\n\nexport type CreateTimestampTokenErrorContext = Partial<Pick<CreatedTimestampToken, 'logHistory' | 'providerName'>>\n\n/**\n * Custom error class that encapsulates context about token creation, including the provider used and the associated log history\n */\nexport class CreateTimestampTokenError extends Error {\n  constructor(\n    message: string,\n    readonly context: CreateTimestampTokenErrorContext = {},\n    options?: ErrorOptions\n  ) {\n    super(message, options)\n  }\n}\n","import { CertService } from '@techteamer/cert-utils'\nimport { FileOptions as TempFileOptions } from 'tmp'\n\nimport { TimestampInfo } from './TrustedTimestampInfo'\nimport { TrustedTimestampRequest } from './TrustedTimestampRequest'\nimport {\n  checkSslPath,\n  extractCertFromToken,\n  generateTsReply,\n  getTsQuery,\n  getTsReply,\n  getTsVerify\n} from './TrustedTimestampCommand'\nimport { checkDigest, checkDigestFormat, normalizeDigestFormat } from './TrustedTimestampCheck'\nimport { TempFileService } from '../util/TempFileService'\nimport { CreateTimestampTokenError } from './error/create-timestamp-token.error'\nimport type { TimestampConfig } from './types/timestamp-config.type'\nimport type { TimestampProvider } from './types/timestamp-provider.type'\nimport type { CreatedTimestampToken, Timestamp } from './types/timestamp-token.type'\n\n/**\n * OpenSSL docs: https://www.openssl.org/docs/manmaster/man1/ts.html\n *\n * Certificate Installation with OpenSSL: http://gagravarr.org/writing/openssl-certs/others.shtml\n *\n * Trustedtimestamp service implements the generate, import and verification of timestamps\n *\n * */\nexport class TrustedTimestampService {\n  private readonly tmpOptions: TempFileOptions = { prefix: 'request-', postfix: '.tsr' }\n  private tempFileService!: TempFileService\n  private certService!: CertService\n  private providers!: TimestampProvider[]\n  private certsLocation!: string\n  private timestampRequest!: TrustedTimestampRequest\n\n  constructor(\n    private readonly timestampInfoType: 'normal' | 'short' = 'normal',\n    private readonly config: TimestampConfig = {} as TimestampConfig,\n    private readonly encoding = 'latin1'\n  ) {\n    this._init()\n  }\n\n  /**\n   * init method that sets the config and instantiates the required services\n   * */\n  private _init(): void {\n    if (this.config) {\n      if (!this.config?.certsLocation) {\n        throw new Error('trustedTimestamp config \"certsLocation\" missing!')\n      }\n\n      if (!this.config?.providers?.length) {\n        throw new Error('trustedTimestamp config \"providers\" missing or empty!')\n      }\n\n      this.tempFileService = new TempFileService()\n      this.certService = new CertService(this.encoding)\n      this.providers = this.config.providers\n      this.certsLocation = this.config.certsLocation\n      this.timestampRequest = new TrustedTimestampRequest(this.providers, this.tempFileService, this.tmpOptions)\n    }\n  }\n\n  /**\n   * Utility method that resolves to a TimestampInfo object containing parsed info from the tsr\n   * */\n  async getTimestampInfo(tsr: Buffer, isToken = false): Promise<TimestampInfo> {\n    const cleanupTempFns: (() => unknown)[] = []\n    let inputTempPath = ''\n\n    try {\n      const tsrtmp = await this.tempFileService.createTempFile(this.tmpOptions, tsr)\n      inputTempPath = tsrtmp.tempPath\n      cleanupTempFns.push(tsrtmp.cleanupCallback)\n\n      const responseText = await getTsReply(inputTempPath, isToken)\n      const timestampInfo = new TimestampInfo(this.timestampInfoType, responseText)\n\n      // get cert info\n\n      try {\n        // get raw token if the input was a whole response (TimestampResponse->TimestampToken)\n        let tstPath\n        if (isToken) {\n          tstPath = inputTempPath\n        } else {\n          const tmp = await this.tempFileService.createTempFile(this.tmpOptions)\n          await generateTsReply(inputTempPath, tmp.tempPath)\n          tstPath = tmp.tempPath\n          cleanupTempFns.push(tmp.cleanupCallback)\n        }\n\n        // extract cert from token\n        const x509Cert = await extractCertFromToken(tstPath)\n        // parse cert\n        const certInfo = await this.certService.parseCert(Buffer.from(x509Cert), '', this.certService.CertType.PEM)\n\n        if (this.timestampInfoType === 'normal') {\n          timestampInfo.setCertInfo(certInfo)\n        }\n      } catch (err) {\n        throw new Error('Unable to get cert info from timestamp token', err as Error)\n      }\n\n      return timestampInfo\n    } catch (err) {\n      return new TimestampInfo(this.timestampInfoType, null!, (err as Error).message)\n    } finally {\n      for (const cleanUpFn of cleanupTempFns) {\n        if (typeof cleanUpFn === 'function') {\n          cleanUpFn()\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a TimestampToken instance for a hash digest and a hash algorithm.\n   * It requests a token from the TSA and verifies the received response.\n   * The returned timestamp token represents the token\n   * and contains the tsr with the verification result.\n   * */\n  async createTimestampToken(digest: string, hashAlgorithm: string, dataSize: number): Promise<CreatedTimestampToken> {\n    const digestFormat = normalizeDigestFormat(hashAlgorithm)\n\n    try {\n      if (!checkDigestFormat(digestFormat)) {\n        throw new Error(`Unknown digest format: ${hashAlgorithm}`)\n      }\n      if (!checkDigest(digest)) {\n        throw new Error(`Invalid digest: ${digest}`)\n      }\n\n      const tsQuery = await getTsQuery(digest, digestFormat)\n      console.log('!!!!!!!!!!!!!!!')\n      console.log(tsQuery)\n      const { tsr, providerName, logHistory } = await this.timestampRequest.getTimestamp(tsQuery)\n      if (!tsr) {\n        throw new CreateTimestampTokenError('Failed to create trusted timestamp, no provider was available', {\n          providerName,\n          logHistory\n        })\n      }\n      const timestampInfo = await this.getTimestampInfo(tsr, false)\n      const certExpiry = timestampInfo.certInfo?.notAfter || null\n      const tt: Timestamp = {\n        digest,\n        hashAlgorithm,\n        dataSize,\n        tsr,\n        isToken: false,\n        certExpiry,\n        verified: null // not yet\n      }\n\n      tt.verified = await this.verifyToken(tt, digest, dataSize)\n\n      return { timestamp: tt, providerName, logHistory }\n    } catch (error) {\n      if (error instanceof CreateTimestampTokenError) {\n        throw error\n      }\n\n      throw new CreateTimestampTokenError(`Failed to create trusted timestamp ${(error as Error).message}`)\n    }\n  }\n\n  /**\n   * Verify if a timestamp token corresponds to a particular hash of data\n   * */\n  async verifyToken(timestampToken: Timestamp, digest: string, dataSize: number): Promise<boolean> {\n    if (timestampToken.dataSize !== dataSize) {\n      throw new Error(\n        `Timestamp token verification failed: The provided data size (${dataSize}) does not match the time stamped size (${timestampToken.dataSize}).`\n      )\n    }\n\n    if (timestampToken.digest !== digest) {\n      throw new Error(\n        `Timestamp token verification failed: The provided digest (${digest}) does not match the time stamped digest (${timestampToken.digest}).`\n      )\n    }\n\n    // verify token\n    return await this.verifyTsr(digest, timestampToken.tsr, timestampToken.isToken)\n  }\n\n  /**\n   * Verify a hash digest against a timestamp response file\n   * */\n  async verifyTsr(digest: string, tsr: Buffer, isToken = false): Promise<boolean> {\n    let cleanupTempFile = null\n\n    try {\n      if (!checkDigest(digest)) {\n        throw new Error(`Invalid digest: ${digest}`)\n      }\n\n      // save the tsr on disk because openssl can only read it from file\n      const { tempPath, cleanupCallback } = await this.tempFileService.createTempFile(this.tmpOptions, tsr)\n      cleanupTempFile = cleanupCallback\n\n      const stdout = await getTsVerify(digest, tempPath, isToken, this.certsLocation)\n\n      const verificationResult = /Verification: OK/i.test(stdout)\n\n      if (cleanupTempFile) {\n        cleanupTempFile()\n      }\n\n      return verificationResult\n    } catch (err) {\n      if (typeof cleanupTempFile === 'function') {\n        cleanupTempFile()\n      }\n\n      throw new Error(`Failed to verify tsr ${(err as Error).message}`)\n    }\n  }\n\n  /**\n   * testService method that check the ssl installation\n   * */\n  async testService(): Promise<string> {\n    return await checkSslPath()\n  }\n}\n"],"names":["ProxyAgent","childProcess","fs","CertService"],"mappings":"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"}